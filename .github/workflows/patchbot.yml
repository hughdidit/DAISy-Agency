name: Patchbot

on:
  pull_request:
    types: [opened, synchronize, reopened, labeled, ready_for_review, closed]
    branches: [daisy/dev]
  pull_request_review:
    types: [submitted]
    branches: [daisy/dev]
  check_suite:
    types: [completed]
    branches: [daisy/dev]
  workflow_run:
    workflows: ["Deploy staging on release"]
    types: [completed]
    branches: [daisy/dev]
  workflow_dispatch:
    inputs:
      pr_number:
        required: true
        type: number
      phase:
        required: true
        type: choice
        options:
          - triage
          - ci-summary
          - approval-gate
          - merge-detect
          - deploy-complete

permissions:
  contents: read
  pull-requests: write
  checks: read
  actions: read

concurrency:
  group: patchbot-${{ github.event.pull_request.number || inputs.pr_number || github.run_id }}
  cancel-in-progress: false

jobs:
  # ──────────────────────────────────────────────
  # Job 1: Router
  # Determines phase, pr_number, head_sha, skip
  # ──────────────────────────────────────────────
  router:
    runs-on: ubuntu-latest
    outputs:
      phase: ${{ steps.route.outputs.phase }}
      pr_number: ${{ steps.route.outputs.pr_number }}
      head_sha: ${{ steps.route.outputs.head_sha }}
      skip: ${{ steps.route.outputs.skip }}
    steps:
      - name: Route event to phase
        id: route
        uses: actions/github-script@v7
        with:
          script: |
            // Kill switch
            const enabled = '${{ vars.PATCHBOT_ENABLED }}';
            if (enabled === 'false') {
              core.info('Patchbot is disabled (PATCHBOT_ENABLED=false)');
              core.setOutput('skip', 'true');
              return;
            }

            const event = context.eventName;
            let phase = '';
            let prNumber = 0;
            let headSha = '';
            let skip = 'false';

            if (event === 'workflow_dispatch') {
              phase = '${{ inputs.phase }}';
              prNumber = Number(${{ inputs.pr_number || 0 }});
              if (!Number.isInteger(prNumber) || prNumber <= 0) {
                core.setFailed('pr_number must be a positive integer for workflow_dispatch');
                return;
              }
              const { data: pr } = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber,
              });
              headSha = pr.head.sha;

            } else if (event === 'pull_request') {
              const action = context.payload.action;
              prNumber = context.payload.pull_request.number;
              headSha = context.payload.pull_request.head.sha;

              if (action === 'closed') {
                // Merge-detect: PR closed + merged + has patchbot:ready label
                const pr = context.payload.pull_request;
                if (pr.merged) {
                  const labels = pr.labels.map(l => l.name);
                  if (labels.includes('patchbot:ready')) {
                    phase = 'merge-detect';
                    headSha = pr.merge_commit_sha;
                  } else {
                    core.info('PR merged but does not have patchbot:ready label');
                    skip = 'true';
                  }
                } else {
                  core.info('PR closed without merge');
                  skip = 'true';
                }
              } else if (action === 'labeled') {
                const label = context.payload.label.name;
                if (label === 'patchbot:approved') {
                  phase = 'approval-gate';
                } else {
                  core.info(`Ignoring labeled event for label: ${label}`);
                  skip = 'true';
                }
              } else if (context.payload.pull_request.draft) {
                core.info('Skipping draft PR');
                skip = 'true';
              } else {
                // opened, synchronize, reopened, ready_for_review
                phase = 'triage';
              }

            } else if (event === 'pull_request_review') {
              const review = context.payload.review;
              if (review.state.toLowerCase() !== 'approved') {
                core.info(`Ignoring review with state: ${review.state}`);
                skip = 'true';
              } else {
                phase = 'approval-gate';
                prNumber = context.payload.pull_request.number;
                headSha = context.payload.pull_request.head.sha;
              }

            } else if (event === 'check_suite') {
              const checkSuite = context.payload.check_suite;
              headSha = checkSuite.head_sha;

              // Find open PRs for this commit
              const prs = checkSuite.pull_requests || [];
              const openPr = prs.find(pr => pr.base.ref === 'daisy/dev');
              if (!openPr) {
                core.info('check_suite is not for a PR targeting daisy/dev');
                skip = 'true';
              } else {
                prNumber = openPr.number;

                // Only proceed if PR has patchbot:triaged label
                const { data: labels } = await github.rest.issues.listLabelsOnIssue({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                });
                const hasTriaged = labels.some(l => l.name === 'patchbot:triaged');
                if (!hasTriaged) {
                  core.info('PR does not have patchbot:triaged label, skipping check_suite');
                  skip = 'true';
                } else {
                  phase = 'ci-summary';
                }
              }

            } else if (event === 'workflow_run') {
              // Deploy staging on release completed — correlate to PR in deploy-complete job
              phase = 'deploy-complete';
              headSha = context.payload.workflow_run.head_sha;
              // prNumber resolved in the deploy-complete job itself

            } else {
              core.info(`Unhandled event: ${event}`);
              skip = 'true';
            }

            core.setOutput('phase', phase);
            core.setOutput('pr_number', String(prNumber));
            core.setOutput('head_sha', headSha);
            core.setOutput('skip', skip);
            core.info(`phase=${phase} pr=${prNumber} sha=${headSha} skip=${skip}`);

  # ──────────────────────────────────────────────
  # Job 2: Triage
  # ──────────────────────────────────────────────
  triage:
    needs: router
    if: needs.router.outputs.skip != 'true' && needs.router.outputs.phase == 'triage'
    runs-on: ubuntu-latest
    steps:
      - name: Run triage rules
        id: triage
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = ${{ needs.router.outputs.pr_number }};
            const headSha = '${{ needs.router.outputs.head_sha }}';

            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
            });

            const sections = {
              triage: { status: 'running', detail: 'Checking...' },
              ci: { status: 'pending', detail: '' },
              approval: { status: 'pending', detail: '' },
            };

            // Rule: Target branch must be daisy/dev
            if (pr.base.ref !== 'daisy/dev') {
              sections.triage = { status: 'fail', detail: `Target branch is \`${pr.base.ref}\`, expected \`daisy/dev\`` };
              await updateComment(github, context, prNumber, sections, '${{ github.run_id }}', '${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}');
              core.info('PR does not target daisy/dev, skipping');
              return;
            }

            // Rule: Author allowlist
            const allowedAuthors = '${{ vars.PATCHBOT_ALLOWED_AUTHORS }}'.trim();
            if (allowedAuthors) {
              const allowed = allowedAuthors.split(',').map(a => a.trim().toLowerCase());
              if (!allowed.includes(pr.user.login.toLowerCase())) {
                sections.triage = { status: 'fail', detail: `Author \`${pr.user.login}\` is not in the allowlist` };
                await updateComment(github, context, prNumber, sections, '${{ github.run_id }}', '${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}');
                core.info(`Author ${pr.user.login} not in allowlist`);
                return;
              }
            }

            // Rule: No workflow files
            const files = await github.paginate(github.rest.pulls.listFiles, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
            });
            const workflowFiles = files.filter(f => f.filename.startsWith('.github/workflows/'));
            if (workflowFiles.length > 0) {
              const fileList = workflowFiles.map(f => `\`${f.filename}\``).join(', ');
              sections.triage = {
                status: 'fail',
                detail: `PR modifies workflow files (${fileList}). Patchbot cannot manage workflow PRs due to GITHUB_TOKEN restrictions.`,
              };
              await updateComment(github, context, prNumber, sections, '${{ github.run_id }}', '${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}');
              core.info('PR touches workflow files, skipping');
              return;
            }

            // All rules passed — add triaged label, remove stale CI labels
            const labelOps = [];

            // Add patchbot:triaged
            labelOps.push(
              github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                labels: ['patchbot:triaged'],
              })
            );

            // Remove stale labels (ignore 404 "not found", surface other errors)
            for (const stale of ['patchbot:ci-pass', 'patchbot:ci-fail', 'patchbot:approved', 'patchbot:ready']) {
              labelOps.push(
                github.rest.issues.removeLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  name: stale,
                }).catch(err => {
                  if (err.status === 404) return;
                  core.warning(`Failed to remove label "${stale}": ${err.message}`);
                })
              );
            }
            await Promise.all(labelOps);

            sections.triage = { status: 'pass', detail: 'Passed' };
            sections.ci = { status: 'pending', detail: 'Waiting for CI...' };
            await updateComment(github, context, prNumber, sections, '${{ github.run_id }}', '${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}');
            core.setOutput('triaged', 'true');

            // ── Comment helper ──
            async function updateComment(github, context, prNumber, sections, runId, runUrl) {
              const marker = '<!-- patchbot-status -->';
              const body = buildCommentBody(sections, runId, runUrl);

              const comments = await github.paginate(github.rest.issues.listComments, {
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
              });
              const existing = comments.find(c => c.body?.includes(marker));

              if (existing) {
                await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: existing.id,
                  body,
                });
              } else {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  body,
                });
              }
            }

            function buildCommentBody(sections, runId, runUrl) {
              const icons = { pass: '\u2705', fail: '\u274c', pending: '\u23f3', running: '\u23f3', skip: '\u25fb\ufe0f' };
              const stageRows = [
                ['Triage', sections.triage],
                ['CI', sections.ci],
                ['Approval', sections.approval],
                ['Release', sections.release || { status: 'pending', detail: '' }],
                ['Deploy', sections.deploy || { status: 'pending', detail: '' }],
                ['Verify', sections.verify || { status: 'pending', detail: '' }],
              ];

              let md = '<!-- patchbot-status -->\n';
              md += '## Patchbot\n\n';
              md += '| Stage | Status |\n';
              md += '|-------|--------|\n';
              for (const [name, s] of stageRows) {
                const icon = icons[s.status] || '\u2753';
                const detail = s.detail || s.status;
                md += `| ${name} | ${icon} ${detail} |\n`;
              }

              if (sections.ciDetails) {
                const { checks, passed, total } = sections.ciDetails;
                md += `\n<details>\n<summary>CI Checks (${passed}/${total} passed)</summary>\n\n`;
                md += '| Check | Result |\n';
                md += '|-------|--------|\n';
                for (const check of checks) {
                  md += `| ${check.name} | ${check.icon} |\n`;
                }
                md += '\n</details>\n';
              }

              md += `\n---\n`;
              md += `<sub>Updated ${new Date().toISOString()} \u00b7 <a href="${runUrl}">Run #${runId}</a></sub>\n`;
              md += '<!-- /patchbot-status -->';
              return md;
            }

  # ──────────────────────────────────────────────
  # Job 3: CI Summary
  # Runs after triage OR on check_suite events
  # ──────────────────────────────────────────────
  ci-summary:
    needs: [router, triage]
    if: |
      always()
      && needs.router.outputs.skip != 'true'
      && (
        (needs.router.outputs.phase == 'ci-summary')
        || (needs.router.outputs.phase == 'triage' && needs.triage.result == 'success')
      )
    runs-on: ubuntu-latest
    steps:
      - name: Summarize CI checks
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = ${{ needs.router.outputs.pr_number }};
            const headSha = '${{ needs.router.outputs.head_sha }}';
            const runId = '${{ github.run_id }}';
            const runUrl = '${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}';

            // Guard: PR must have patchbot:triaged label
            const { data: labels } = await github.rest.issues.listLabelsOnIssue({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
            });
            const hasTriaged = labels.some(l => l.name === 'patchbot:triaged');
            if (!hasTriaged) {
              core.info('PR does not have patchbot:triaged label, skipping ci-summary');
              return;
            }

            // Fetch all check runs for head_sha (paginated)
            // checks.listForRef returns check runs under response.data.check_runs;
            // github.paginate uses this mapper to collect and flatten all pages
            const checkRuns = await github.paginate(
              github.rest.checks.listForRef,
              {
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: headSha,
                per_page: 100,
              },
              (response) => response.data.check_runs
            );

            // Fetch commit statuses
            const { data: statusData } = await github.rest.repos.getCombinedStatusForRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: headSha,
            });

            // Exclude Patchbot's own check runs (workflow name prefix)
            const filtered = checkRuns.filter(cr => !cr.name.startsWith('Patchbot'));

            // Build check table
            const conclusionIcons = {
              success: '\u2705',
              failure: '\u274c',
              cancelled: '\u26d4',
              skipped: '\u23ed\ufe0f',
              timed_out: '\u23f0',
              action_required: '\u26a0\ufe0f',
              neutral: '\u25ab\ufe0f',
              stale: '\u25ab\ufe0f',
            };

            const checks = [];
            let completed = 0;
            let passed = 0;
            let failed = 0;
            let inProgress = 0;

            for (const cr of filtered) {
              const name = cr.name;
              const link = cr.html_url ? `[${name}](${cr.html_url})` : name;

              if (cr.status !== 'completed') {
                checks.push({ name: link, icon: '\u23f3', conclusion: 'in_progress' });
                inProgress++;
              } else {
                const conclusion = cr.conclusion || 'neutral';
                const icon = conclusionIcons[conclusion] || '\u2753';
                checks.push({ name: link, icon, conclusion });
                completed++;
                if (conclusion === 'success' || conclusion === 'skipped' || conclusion === 'neutral') {
                  passed++;
                } else {
                  failed++;
                }
              }
            }

            // Include commit statuses
            for (const status of statusData.statuses || []) {
              const name = status.context;
              const link = status.target_url ? `[${name}](${status.target_url})` : name;
              const stateMap = { success: '\u2705', failure: '\u274c', error: '\u274c', pending: '\u23f3' };
              const icon = stateMap[status.state] || '\u2753';
              checks.push({ name: link, icon, conclusion: status.state });
              if (status.state === 'pending') {
                inProgress++;
              } else {
                completed++;
                if (status.state === 'success') {
                  passed++;
                } else {
                  failed++;
                }
              }
            }

            const total = checks.length;

            // Determine overall CI status
            const hasApproved = labels.some(l => l.name === 'patchbot:approved');

            const sections = {
              triage: { status: 'pass', detail: 'Passed' },
              ci: { status: 'pending', detail: '' },
              approval: hasApproved
                ? { status: 'pass', detail: 'Approved' }
                : { status: 'pending', detail: 'Awaiting review' },
            };

            if (total === 0) {
              sections.ci = { status: 'pending', detail: 'No CI checks found yet' };
            } else if (inProgress > 0) {
              sections.ci = { status: 'running', detail: `${passed}/${total} passed, ${inProgress} in progress` };
            } else if (failed > 0) {
              sections.ci = { status: 'fail', detail: `${passed}/${total} passed, ${failed} failed` };
              // Add ci-fail label, remove ci-pass
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                labels: ['patchbot:ci-fail'],
              });
              await github.rest.issues.removeLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                name: 'patchbot:ci-pass',
              }).catch(err => { if (err.status !== 404) throw err; });
            } else {
              sections.ci = { status: 'pass', detail: `${passed}/${total} passed` };
              // Add ci-pass label, remove ci-fail
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                labels: ['patchbot:ci-pass'],
              });
              await github.rest.issues.removeLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                name: 'patchbot:ci-fail',
              }).catch(err => { if (err.status !== 404) throw err; });
            }

            sections.ciDetails = { checks, passed, total };

            await updateComment(github, context, prNumber, sections, runId, runUrl);

            // ── Comment helper (defined locally for this job) ──
            async function updateComment(github, context, prNumber, sections, runId, runUrl) {
              const marker = '<!-- patchbot-status -->';
              const body = buildCommentBody(sections, runId, runUrl);

              const comments = await github.paginate(github.rest.issues.listComments, {
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
              });
              const existing = comments.find(c => c.body?.includes(marker));

              if (existing) {
                await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: existing.id,
                  body,
                });
              } else {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  body,
                });
              }
            }

            function buildCommentBody(sections, runId, runUrl) {
              const icons = { pass: '\u2705', fail: '\u274c', pending: '\u23f3', running: '\u23f3', skip: '\u25fb\ufe0f' };
              const stageRows = [
                ['Triage', sections.triage],
                ['CI', sections.ci],
                ['Approval', sections.approval],
                ['Release', sections.release || { status: 'pending', detail: '' }],
                ['Deploy', sections.deploy || { status: 'pending', detail: '' }],
                ['Verify', sections.verify || { status: 'pending', detail: '' }],
              ];

              let md = '<!-- patchbot-status -->\n';
              md += '## Patchbot\n\n';
              md += '| Stage | Status |\n';
              md += '|-------|--------|\n';
              for (const [name, s] of stageRows) {
                const icon = icons[s.status] || '\u2753';
                const detail = s.detail || s.status;
                md += `| ${name} | ${icon} ${detail} |\n`;
              }

              if (sections.ciDetails) {
                const { checks, passed, total } = sections.ciDetails;
                md += `\n<details>\n<summary>CI Checks (${passed}/${total} passed)</summary>\n\n`;
                md += '| Check | Result |\n';
                md += '|-------|--------|\n';
                for (const check of checks) {
                  md += `| ${check.name} | ${check.icon} |\n`;
                }
                md += '\n</details>\n';
              }

              md += `\n---\n`;
              md += `<sub>Updated ${new Date().toISOString()} \u00b7 <a href="${runUrl}">Run #${runId}</a></sub>\n`;
              md += '<!-- /patchbot-status -->';
              return md;
            }

  # ──────────────────────────────────────────────
  # Job 4: Approval Gate
  # ──────────────────────────────────────────────
  approval-gate:
    needs: router
    if: needs.router.outputs.skip != 'true' && needs.router.outputs.phase == 'approval-gate'
    runs-on: ubuntu-latest
    steps:
      - name: Check approval gate
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = ${{ needs.router.outputs.pr_number }};
            const headSha = '${{ needs.router.outputs.head_sha }}';
            const runId = '${{ github.run_id }}';
            const runUrl = '${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}';

            // Fetch current labels
            const { data: labels } = await github.rest.issues.listLabelsOnIssue({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
            });
            const labelNames = labels.map(l => l.name);

            const hasTriaged = labelNames.includes('patchbot:triaged');
            const hasCiPass = labelNames.includes('patchbot:ci-pass');
            const hasCiFail = labelNames.includes('patchbot:ci-fail');
            const hasApproved = labelNames.includes('patchbot:approved');
            const hasReady = labelNames.includes('patchbot:ready');

            const sections = {
              triage: hasTriaged
                ? { status: 'pass', detail: 'Passed' }
                : { status: 'pending', detail: 'Not triaged' },
              ci: hasCiPass
                ? { status: 'pass', detail: 'All checks passed' }
                : hasCiFail
                  ? { status: 'fail', detail: 'Some checks failed' }
                  : { status: 'pending', detail: 'Waiting for CI...' },
              approval: { status: 'pending', detail: '' },
            };

            // Re-fetch CI check data so the comment preserves the CI details table
            const checkRuns = await github.paginate(
              github.rest.checks.listForRef,
              { owner: context.repo.owner, repo: context.repo.repo, ref: headSha, per_page: 100 },
              (response) => response.data.check_runs
            );
            const ciFiltered = checkRuns.filter(cr => !cr.name.startsWith('Patchbot'));
            const conclusionIcons = {
              success: '\u2705', failure: '\u274c', cancelled: '\u26d4',
              skipped: '\u23ed\ufe0f', timed_out: '\u23f0', action_required: '\u26a0\ufe0f',
              neutral: '\u25ab\ufe0f', stale: '\u25ab\ufe0f',
            };
            const ciChecks = [];
            let ciPassed = 0;
            for (const cr of ciFiltered) {
              const link = cr.html_url ? `[${cr.name}](${cr.html_url})` : cr.name;
              if (cr.status !== 'completed') {
                ciChecks.push({ name: link, icon: '\u23f3' });
              } else {
                const conclusion = cr.conclusion || 'neutral';
                ciChecks.push({ name: link, icon: conclusionIcons[conclusion] || '\u2753' });
                if (conclusion === 'success' || conclusion === 'skipped' || conclusion === 'neutral') ciPassed++;
              }
            }
            sections.ciDetails = { checks: ciChecks, passed: ciPassed, total: ciChecks.length };

            // Guard: CI must have passed
            if (!hasCiPass) {
              sections.approval = { status: 'fail', detail: 'Cannot approve: CI has not passed' };
              await updateComment(github, context, prNumber, sections, runId, runUrl);
              core.info('CI has not passed, cannot approve');
              return;
            }

            // Check approval sources: always require an actual approving review
            const reviews = await github.paginate(github.rest.pulls.listReviews, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
            });
            const isApproved = reviews.some(r => r.state && r.state.toLowerCase() === 'approved');

            if (isApproved) {
              const labelsToAdd = [];
              if (!hasApproved) labelsToAdd.push('patchbot:approved');
              if (!hasReady) labelsToAdd.push('patchbot:ready');

              if (labelsToAdd.length > 0) {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  labels: labelsToAdd,
                });
              }

              sections.approval = { status: 'pass', detail: 'Approved' };
            } else {
              sections.approval = { status: 'pending', detail: 'Awaiting review' };
            }

            await updateComment(github, context, prNumber, sections, runId, runUrl);

            // ── Comment helper (defined locally for this job) ──
            async function updateComment(github, context, prNumber, sections, runId, runUrl) {
              const marker = '<!-- patchbot-status -->';
              const body = buildCommentBody(sections, runId, runUrl);

              const comments = await github.paginate(github.rest.issues.listComments, {
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
              });
              const existing = comments.find(c => c.body?.includes(marker));

              if (existing) {
                await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: existing.id,
                  body,
                });
              } else {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  body,
                });
              }
            }

            function buildCommentBody(sections, runId, runUrl) {
              const icons = { pass: '\u2705', fail: '\u274c', pending: '\u23f3', running: '\u23f3', skip: '\u25fb\ufe0f' };
              const stageRows = [
                ['Triage', sections.triage],
                ['CI', sections.ci],
                ['Approval', sections.approval],
                ['Release', sections.release || { status: 'pending', detail: '' }],
                ['Deploy', sections.deploy || { status: 'pending', detail: '' }],
                ['Verify', sections.verify || { status: 'pending', detail: '' }],
              ];

              let md = '<!-- patchbot-status -->\n';
              md += '## Patchbot\n\n';
              md += '| Stage | Status |\n';
              md += '|-------|--------|\n';
              for (const [name, s] of stageRows) {
                const icon = icons[s.status] || '\u2753';
                const detail = s.detail || s.status;
                md += `| ${name} | ${icon} ${detail} |\n`;
              }

              if (sections.ciDetails) {
                const { checks, passed, total } = sections.ciDetails;
                md += `\n<details>\n<summary>CI Checks (${passed}/${total} passed)</summary>\n\n`;
                md += '| Check | Result |\n';
                md += '|-------|--------|\n';
                for (const check of checks) {
                  md += `| ${check.name} | ${check.icon} |\n`;
                }
                md += '\n</details>\n';
              }

              md += `\n---\n`;
              md += `<sub>Updated ${new Date().toISOString()} \u00b7 <a href="${runUrl}">Run #${runId}</a></sub>\n`;
              md += '<!-- /patchbot-status -->';
              return md;
            }

  # ──────────────────────────────────────────────
  # Job 5: Merge Detect
  # Fires when a patchbot:ready PR is merged
  # ──────────────────────────────────────────────
  merge-detect:
    needs: router
    if: needs.router.outputs.skip != 'true' && needs.router.outputs.phase == 'merge-detect'
    runs-on: ubuntu-latest
    environment: staging
    steps:
      - name: Handle merged PR
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = ${{ needs.router.outputs.pr_number }};
            const headSha = '${{ needs.router.outputs.head_sha }}';
            const runId = '${{ github.run_id }}';
            const runUrl = '${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}';

            // Add patchbot:releasing label
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              labels: ['patchbot:releasing'],
            });

            // Update comment
            const sections = {
              triage: { status: 'pass', detail: 'Passed' },
              ci: { status: 'pass', detail: 'All checks passed' },
              approval: { status: 'pass', detail: 'Approved' },
              release: { status: 'running', detail: 'Building image...' },
              deploy: { status: 'pending', detail: '' },
              verify: { status: 'pending', detail: '' },
            };

            await updateComment(github, context, prNumber, sections, runId, runUrl);

            // Discord notification
            const webhookUrl = '${{ secrets.DISCORD_WEBHOOK_URL }}';
            if (webhookUrl) {
              const prUrl = `${{ github.server_url }}/${{ github.repository }}/pull/${prNumber}`;
              const payload = {
                content: `\u{1F680} PR #${prNumber} merged, building release... [View PR](${prUrl})`,
              };
              await fetch(webhookUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload),
              }).catch(err => core.warning(`Discord notification failed: ${err.message}`));
            }

            // ── Comment helper ──
            async function updateComment(github, context, prNumber, sections, runId, runUrl) {
              const marker = '<!-- patchbot-status -->';
              const body = buildCommentBody(sections, runId, runUrl);

              const comments = await github.paginate(github.rest.issues.listComments, {
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
              });
              const existing = comments.find(c => c.body?.includes(marker));

              if (existing) {
                await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: existing.id,
                  body,
                });
              } else {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  body,
                });
              }
            }

            function buildCommentBody(sections, runId, runUrl) {
              const icons = { pass: '\u2705', fail: '\u274c', pending: '\u23f3', running: '\u23f3', skip: '\u25fb\ufe0f' };
              const stageRows = [
                ['Triage', sections.triage],
                ['CI', sections.ci],
                ['Approval', sections.approval],
                ['Release', sections.release || { status: 'pending', detail: '' }],
                ['Deploy', sections.deploy || { status: 'pending', detail: '' }],
                ['Verify', sections.verify || { status: 'pending', detail: '' }],
              ];

              let md = '<!-- patchbot-status -->\n';
              md += '## Patchbot\n\n';
              md += '| Stage | Status |\n';
              md += '|-------|--------|\n';
              for (const [name, s] of stageRows) {
                const icon = icons[s.status] || '\u2753';
                const detail = s.detail || s.status;
                md += `| ${name} | ${icon} ${detail} |\n`;
              }

              md += `\n---\n`;
              md += `<sub>Updated ${new Date().toISOString()} \u00b7 <a href="${runUrl}">Run #${runId}</a></sub>\n`;
              md += '<!-- /patchbot-status -->';
              return md;
            }

  # ──────────────────────────────────────────────
  # Job 6: Deploy Complete
  # Fires when deploy-staging-on-release completes
  # ──────────────────────────────────────────────
  deploy-complete:
    needs: router
    if: needs.router.outputs.skip != 'true' && needs.router.outputs.phase == 'deploy-complete'
    runs-on: ubuntu-latest
    environment: staging
    permissions:
      contents: read
      pull-requests: write
      checks: read
      actions: write
    steps:
      - name: Process deploy result
        uses: actions/github-script@v7
        with:
          script: |
            const headSha = '${{ needs.router.outputs.head_sha }}';
            const triggeringRunId = ${{ github.event.workflow_run.id || 0 }};
            const triggeringConclusion = '${{ github.event.workflow_run.conclusion }}';
            const runId = '${{ github.run_id }}';
            const runUrl = '${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}';

            // ── Step 1: Correlate to PR via commit SHA ──
            const { data: prList } = await github.rest.repos.listPullRequestsAssociatedWithCommit({
              owner: context.repo.owner,
              repo: context.repo.repo,
              commit_sha: headSha,
            });

            // Find merged PR with patchbot:releasing label
            const pr = prList.find(p =>
              p.merged_at &&
              p.base.ref === 'daisy/dev' &&
              p.labels.some(l => l.name === 'patchbot:releasing')
            );

            if (!pr) {
              core.info(`No merged PR with patchbot:releasing label found for SHA ${headSha}`);
              return;
            }

            const prNumber = pr.number;
            core.info(`Correlated to PR #${prNumber}`);

            // ── Step 2: Fetch job outcomes from the triggering run ──
            let deployOutcome = 'unknown';
            let verifyOutcome = 'unknown';

            if (triggeringRunId > 0) {
              const { data: jobsData } = await github.rest.actions.listJobsForWorkflowRun({
                owner: context.repo.owner,
                repo: context.repo.repo,
                run_id: triggeringRunId,
              });

              for (const job of jobsData.jobs) {
                if (job.name.toLowerCase().includes('deploy')) {
                  deployOutcome = job.conclusion || 'in_progress';
                  core.info(`Deploy job: ${job.name} → ${deployOutcome}`);
                }
                if (job.name.toLowerCase().includes('verify')) {
                  verifyOutcome = job.conclusion || 'in_progress';
                  core.info(`Verify job: ${job.name} → ${verifyOutcome}`);
                }
              }
            }

            // Build short SHA for image tag reference
            const shortSha = headSha.substring(0, 7);

            // ── Step 3: Determine outcome and take action ──
            const sections = {
              triage: { status: 'pass', detail: 'Passed' },
              ci: { status: 'pass', detail: 'All checks passed' },
              approval: { status: 'pass', detail: 'Approved' },
              release: { status: 'pass', detail: `\`dev-${shortSha}\`` },
              deploy: { status: 'pending', detail: '' },
              verify: { status: 'pending', detail: '' },
            };

            const prUrl = `${{ github.server_url }}/${{ github.repository }}/pull/${prNumber}`;
            const webhookUrl = '${{ secrets.DISCORD_WEBHOOK_URL }}';

            if (deployOutcome === 'failure') {
              // ── Deploy failed ──
              sections.deploy = { status: 'fail', detail: 'Staging deploy failed' };
              sections.verify = { status: 'skip', detail: 'Skipped (deploy failed)' };

              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                labels: ['patchbot:verify-fail'],
              });

              await updateComment(github, context, prNumber, sections, runId, runUrl);

              if (webhookUrl) {
                await sendDiscord(webhookUrl,
                  `\u274c PR #${prNumber} staging deploy failed. [View PR](${prUrl})`
                );
              }

            } else if (verifyOutcome === 'failure' || (deployOutcome === 'success' && triggeringConclusion !== 'success')) {
              // ── Verify failed — trigger rollback ──
              // Note: when verify fails, the overall run conclusion is 'failure' even though
              // deploy succeeded. Check deployOutcome first to distinguish the two cases.
              sections.deploy = { status: 'pass', detail: 'Deployed to staging' };
              sections.verify = { status: 'fail', detail: 'Health check failed — rollback in progress' };

              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                labels: ['patchbot:verify-fail'],
              });

              await updateComment(github, context, prNumber, sections, runId, runUrl);

              // Trigger rollback using last-good image ref (bypasses release-metadata artifact)
              const lastGoodImage = '${{ vars.STAGING_LAST_GOOD_IMAGE }}';
              if (lastGoodImage) {
                core.info(`Triggering rollback with image_ref=${lastGoodImage}`);
                await github.rest.actions.createWorkflowDispatch({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  workflow_id: 'deploy.yml',
                  ref: 'daisy/dev',
                  inputs: {
                    environment: 'staging',
                    release_run_id: '0',
                    image_ref: lastGoodImage,
                    dry_run: 'false',
                  },
                });
                core.info('Rollback deploy triggered');
              } else {
                core.warning('No STAGING_LAST_GOOD_IMAGE configured — cannot trigger rollback');
              }

              if (webhookUrl) {
                await sendDiscord(webhookUrl,
                  `\u274c PR #${prNumber} failed staging verification, rolling back. [View PR](${prUrl})`
                );
              }

            } else if (verifyOutcome === 'success') {
              // ── Full success ──
              sections.deploy = { status: 'pass', detail: 'Deployed to staging' };
              sections.verify = { status: 'pass', detail: 'Health check passed' };

              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                labels: ['patchbot:deployed', 'patchbot:verified'],
              });

              // Remove patchbot:releasing label
              await github.rest.issues.removeLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                name: 'patchbot:releasing',
              }).catch(err => { if (err.status !== 404) throw err; });

              await updateComment(github, context, prNumber, sections, runId, runUrl);

              // Save last-good image ref to repo variable (used for rollback via image_ref)
              const imageRef = `ghcr.io/${{ github.repository }}:dev-${shortSha}`.toLowerCase();

              for (const [varName, varValue] of [
                ['STAGING_LAST_GOOD_IMAGE', imageRef],
              ]) {
                try {
                  await github.request('PATCH /repos/{owner}/{repo}/actions/variables/{name}', {
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    name: varName,
                    value: varValue,
                  });
                  core.info(`Updated ${varName}=${varValue}`);
                } catch (err) {
                  if (err.status === 404) {
                    // Variable doesn't exist yet — create it
                    await github.request('POST /repos/{owner}/{repo}/actions/variables', {
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      name: varName,
                      value: varValue,
                    });
                    core.info(`Created ${varName}=${varValue}`);
                  } else {
                    core.warning(`Failed to update ${varName}: ${err.message}`);
                  }
                }
              }

              if (webhookUrl) {
                await sendDiscord(webhookUrl,
                  `\u2705 PR #${prNumber} deployed and verified on staging (\`dev-${shortSha}\`). [View PR](${prUrl})`
                );
              }

            } else {
              // ── Unknown / skipped verify ──
              sections.deploy = { status: 'pass', detail: 'Deployed to staging' };
              sections.verify = { status: 'skip', detail: `Verify outcome: ${verifyOutcome}` };
              await updateComment(github, context, prNumber, sections, runId, runUrl);
            }

            // ── Helpers ──

            async function sendDiscord(url, content) {
              await fetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ content }),
              }).catch(err => core.warning(`Discord notification failed: ${err.message}`));
            }

            async function updateComment(github, context, prNumber, sections, runId, runUrl) {
              const marker = '<!-- patchbot-status -->';
              const body = buildCommentBody(sections, runId, runUrl);

              const comments = await github.paginate(github.rest.issues.listComments, {
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
              });
              const existing = comments.find(c => c.body?.includes(marker));

              if (existing) {
                await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: existing.id,
                  body,
                });
              } else {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  body,
                });
              }
            }

            function buildCommentBody(sections, runId, runUrl) {
              const icons = { pass: '\u2705', fail: '\u274c', pending: '\u23f3', running: '\u23f3', skip: '\u25fb\ufe0f' };
              const stageRows = [
                ['Triage', sections.triage],
                ['CI', sections.ci],
                ['Approval', sections.approval],
                ['Release', sections.release || { status: 'pending', detail: '' }],
                ['Deploy', sections.deploy || { status: 'pending', detail: '' }],
                ['Verify', sections.verify || { status: 'pending', detail: '' }],
              ];

              let md = '<!-- patchbot-status -->\n';
              md += '## Patchbot\n\n';
              md += '| Stage | Status |\n';
              md += '|-------|--------|\n';
              for (const [name, s] of stageRows) {
                const icon = icons[s.status] || '\u2753';
                const detail = s.detail || s.status;
                md += `| ${name} | ${icon} ${detail} |\n`;
              }

              md += `\n---\n`;
              md += `<sub>Updated ${new Date().toISOString()} \u00b7 <a href="${runUrl}">Run #${runId}</a></sub>\n`;
              md += '<!-- /patchbot-status -->';
              return md;
            }
